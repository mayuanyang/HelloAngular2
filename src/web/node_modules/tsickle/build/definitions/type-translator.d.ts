import * as ts from 'typescript';
export declare function assertTypeChecked(sourceFile: ts.SourceFile): void;
export declare function typeToDebugString(type: ts.Type): string;
export declare function symbolToDebugString(sym: ts.Symbol): string;
/** TypeTranslator translates TypeScript types to Closure types. */
export declare class TypeTranslator {
    private typeChecker;
    private node;
    /**
     * @param node is the source AST ts.Node the type comes from.  This is used
     *     in some cases (e.g. anonymous types) for looking up field names.
     */
    constructor(typeChecker: ts.TypeChecker, node: ts.Node);
    /**
     * Converts a ts.Symbol to a string.
     * Other approaches that don't work:
     * - TypeChecker.typeToString translates Array as T[].
     * - TypeChecker.symbolToString emits types without their namespace,
     *   and doesn't let you pass the flag to control that.
     */
    symbolToString(sym: ts.Symbol): string;
    /**
     * @param notNull When true, insert a ! before any type references.  This
     *    is to work around the difference between TS and Closure destructuring.
     */
    translate(type: ts.Type, notNull?: boolean): string;
    private translateTypeLiteral(type);
    /** Converts a ts.Signature (function signature) to a Closure function type. */
    private signatureToClosure(sig);
    warn(msg: string): void;
}
